# データベース設計

## テーブル一覧
- **users**: ユーザーアカウント情報（認証情報、基本ステータス）
- **profiles**: ユーザープロフィール情報（年齢、居住地、自己紹介等）
- **images**: プロフィール画像・動画ファイル情報
- **likes**: いいね履歴（誰が誰にいいねしたか）
- **matches**: マッチング成立情報
- **messages**: チャットメッセージ
- **notifications**: プッシュ通知履歴
- **verification_documents**: 本人確認書類情報
- **points**: ポイント取引履歴（Phase2対応）

## 主要テーブルDDL

### users テーブル
```sql
CREATE TABLE users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_login TIMESTAMP WITH TIME ZONE,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'suspended', 'deleted')),
    email_verified BOOLEAN DEFAULT false,
    is_verified BOOLEAN DEFAULT false, -- 本人確認完了フラグ
    
    -- インデックス
    INDEX idx_users_email (email),
    INDEX idx_users_status (status)
);

-- RLS有効化
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own data" ON users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update own data" ON users FOR UPDATE USING (auth.uid() = id);
```

### profiles テーブル
```sql
CREATE TABLE profiles (
    id UUID REFERENCES users(id) ON DELETE CASCADE PRIMARY KEY,
    display_name VARCHAR(50) NOT NULL,
    age INTEGER NOT NULL CHECK (age >= 18 AND age <= 99),
    gender VARCHAR(10) NOT NULL CHECK (gender IN ('male', 'female', 'other')),
    prefecture VARCHAR(20) NOT NULL,
    city VARCHAR(50),
    occupation VARCHAR(50),
    bio TEXT,
    interests TEXT[], -- 趣味・興味の配列
    
    -- 希望条件
    preferred_min_age INTEGER CHECK (preferred_min_age >= 18),
    preferred_max_age INTEGER CHECK (preferred_max_age <= 99),
    preferred_prefecture VARCHAR(20),
    
    -- システム項目
    profile_completion_rate INTEGER DEFAULT 0 CHECK (profile_completion_rate >= 0 AND profile_completion_rate <= 100),
    last_active TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- インデックス
    INDEX idx_profiles_discovery (age, gender, prefecture) WHERE is_verified = true,
    INDEX idx_profiles_last_active (last_active DESC)
);

-- RLS有効化
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Profiles viewable by verified users" ON profiles 
    FOR SELECT USING (
        EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.is_verified = true)
    );
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
```

### images テーブル
```sql
CREATE TABLE images (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_type VARCHAR(20) NOT NULL CHECK (file_type IN ('image', 'video')),
    file_size INTEGER NOT NULL,
    mime_type VARCHAR(50) NOT NULL,
    order_index INTEGER DEFAULT 0,
    is_primary BOOLEAN DEFAULT false,
    
    -- モデレーション
    moderation_status VARCHAR(20) DEFAULT 'pending' CHECK (
        moderation_status IN ('pending', 'approved', 'rejected')
    ),
    moderation_result JSONB, -- AI審査結果の詳細
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- インデックス・制約
    INDEX idx_images_user (user_id, order_index),
    UNIQUE INDEX idx_images_user_primary (user_id) WHERE is_primary = true
);

-- 画像枚数制限（最大5枚）
CREATE OR REPLACE FUNCTION check_image_limit() 
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT COUNT(*) FROM images WHERE user_id = NEW.user_id) >= 5 THEN
        RAISE EXCEPTION 'Maximum 5 images per user';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_image_limit 
    BEFORE INSERT ON images 
    FOR EACH ROW EXECUTE FUNCTION check_image_limit();

-- RLS有効化
ALTER TABLE images ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage own images" ON images USING (auth.uid() = user_id);
CREATE POLICY "Approved images viewable by verified users" ON images 
    FOR SELECT USING (moderation_status = 'approved');
```

### likes テーブル
```sql
CREATE TABLE likes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    from_user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    to_user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_super_like BOOLEAN DEFAULT false, -- Phase2: スーパーいいね
    
    -- 制約
    CONSTRAINT likes_different_users CHECK (from_user_id != to_user_id),
    UNIQUE INDEX idx_likes_unique (from_user_id, to_user_id),
    
    -- インデックス
    INDEX idx_likes_from_user (from_user_id, created_at DESC),
    INDEX idx_likes_to_user (to_user_id, created_at DESC)
);

-- RLS有効化
ALTER TABLE likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own likes" ON likes 
    FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can create likes" ON likes FOR INSERT WITH CHECK (auth.uid() = from_user_id);
```

### matches テーブル
```sql
CREATE TABLE matches (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user1_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    user2_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    status VARCHAR(20) DEFAULT 'matched' CHECK (
        status IN ('matched', 'unmatched', 'blocked')
    ),
    matched_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    unmatched_at TIMESTAMP WITH TIME ZONE,
    last_message_at TIMESTAMP WITH TIME ZONE,
    
    -- 制約・インデックス
    CONSTRAINT matches_different_users CHECK (user1_id != user2_id),
    CONSTRAINT matches_user_order CHECK (user1_id < user2_id), -- 順序統一
    UNIQUE INDEX idx_matches_unique (user1_id, user2_id),
    INDEX idx_matches_user1_active (user1_id) WHERE status = 'matched',
    INDEX idx_matches_user2_active (user2_id) WHERE status = 'matched',
    INDEX idx_matches_last_message (last_message_at DESC) WHERE status = 'matched'
);

-- マッチ成立時の自動関数
CREATE OR REPLACE FUNCTION create_match_on_mutual_like()
RETURNS TRIGGER AS $$
DECLARE
    mutual_like_exists BOOLEAN;
    match_user1_id UUID;
    match_user2_id UUID;
BEGIN
    -- 相互いいねをチェック
    SELECT EXISTS(
        SELECT 1 FROM likes 
        WHERE from_user_id = NEW.to_user_id 
        AND to_user_id = NEW.from_user_id
    ) INTO mutual_like_exists;
    
    IF mutual_like_exists THEN
        -- ユーザーIDの順序を統一
        IF NEW.from_user_id < NEW.to_user_id THEN
            match_user1_id := NEW.from_user_id;
            match_user2_id := NEW.to_user_id;
        ELSE
            match_user1_id := NEW.to_user_id;
            match_user2_id := NEW.from_user_id;
        END IF;
        
        -- マッチを作成（重複チェック付き）
        INSERT INTO matches (user1_id, user2_id)
        VALUES (match_user1_id, match_user2_id)
        ON CONFLICT (user1_id, user2_id) DO NOTHING;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_match 
    AFTER INSERT ON likes 
    FOR EACH ROW EXECUTE FUNCTION create_match_on_mutual_like();

-- RLS有効化
ALTER TABLE matches ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own matches" ON matches 
    FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
```

### messages テーブル
```sql
CREATE TABLE messages (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    match_id UUID REFERENCES matches(id) ON DELETE CASCADE NOT NULL,
    sender_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    content TEXT NOT NULL,
    message_type VARCHAR(20) DEFAULT 'text' CHECK (
        message_type IN ('text', 'image', 'system')
    ),
    
    -- 既読管理
    read_at TIMESTAMP WITH TIME ZONE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- インデックス
    INDEX idx_messages_match_time (match_id, created_at DESC),
    INDEX idx_messages_sender (sender_id),
    INDEX idx_messages_unread (match_id) WHERE read_at IS NULL
);

-- メッセージ送信時にmatchのlast_message_at更新
CREATE OR REPLACE FUNCTION update_match_last_message()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE matches 
    SET last_message_at = NEW.created_at 
    WHERE id = NEW.match_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_match_last_message 
    AFTER INSERT ON messages 
    FOR EACH ROW EXECUTE FUNCTION update_match_last_message();

-- RLS有効化
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Messages viewable by match participants" ON messages
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM matches 
            WHERE matches.id = messages.match_id 
            AND (matches.user1_id = auth.uid() OR matches.user2_id = auth.uid())
            AND matches.status = 'matched'
        )
    );
CREATE POLICY "Users can send messages to their matches" ON messages
    FOR INSERT WITH CHECK (
        auth.uid() = sender_id AND
        EXISTS (
            SELECT 1 FROM matches 
            WHERE matches.id = match_id 
            AND (matches.user1_id = auth.uid() OR matches.user2_id = auth.uid())
            AND matches.status = 'matched'
        )
    );
```

### verification_documents テーブル
```sql
CREATE TABLE verification_documents (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    document_type VARCHAR(30) NOT NULL CHECK (
        document_type IN ('drivers_license', 'health_insurance', 'mynumber_card')
    ),
    encrypted_file_path VARCHAR(500) NOT NULL, -- 暗号化されたファイルパス
    verification_status VARCHAR(20) DEFAULT 'pending' CHECK (
        verification_status IN ('pending', 'in_progress', 'approved', 'rejected')
    ),
    verification_result JSONB, -- AI審査結果
    verified_age INTEGER,
    rejection_reason TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '30 days'), -- 書類削除期限
    
    -- インデックス
    INDEX idx_verification_user (user_id),
    INDEX idx_verification_status (verification_status),
    INDEX idx_verification_expires (expires_at) WHERE verification_status != 'deleted'
);

-- 自動削除機能（期限切れ書類）
CREATE OR REPLACE FUNCTION cleanup_expired_documents()
RETURNS void AS $$
BEGIN
    DELETE FROM verification_documents 
    WHERE expires_at < NOW() 
    AND verification_status IN ('approved', 'rejected');
END;
$$ LANGUAGE plpgsql;

-- 定期実行設定（日次）
SELECT cron.schedule('cleanup_documents', '0 2 * * *', 'SELECT cleanup_expired_documents();');

-- RLS有効化（管理者のみアクセス可能）
ALTER TABLE verification_documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admin only access" ON verification_documents USING (false); -- 管理者用API経由のみ
```

### notifications テーブル
```sql
CREATE TABLE notifications (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    notification_type VARCHAR(30) NOT NULL CHECK (
        notification_type IN ('like_received', 'match_created', 'message_received', 'system')
    ),
    title VARCHAR(100) NOT NULL,
    body VARCHAR(500) NOT NULL,
    data JSONB, -- 追加データ（match_id, message_id等）
    
    is_read BOOLEAN DEFAULT false,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    read_at TIMESTAMP WITH TIME ZONE,
    
    -- インデックス
    INDEX idx_notifications_user_unread (user_id) WHERE is_read = false,
    INDEX idx_notifications_user_time (user_id, sent_at DESC)
);

-- RLS有効化
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own notifications" ON notifications 
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can update own notifications" ON notifications 
    FOR UPDATE USING (auth.uid() = user_id);
```

### points テーブル（Phase2対応）
```sql
CREATE TABLE points (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    transaction_type VARCHAR(20) NOT NULL CHECK (
        transaction_type IN ('purchase', 'consume', 'bonus', 'refund')
    ),
    amount INTEGER NOT NULL, -- 正数=獲得、負数=消費
    balance_after INTEGER NOT NULL CHECK (balance_after >= 0),
    description VARCHAR(200) NOT NULL,
    related_entity_type VARCHAR(20), -- 'like', 'super_like'等
    related_entity_id UUID,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- インデックス
    INDEX idx_points_user_time (user_id, created_at DESC),
    INDEX idx_points_balance (user_id, balance_after) -- 最新残高取得用
);

-- ポイント残高計算用ビュー
CREATE VIEW user_points_balance AS
SELECT 
    user_id,
    COALESCE(SUM(amount), 0) as total_balance,
    MAX(created_at) as last_transaction_at
FROM points 
GROUP BY user_id;

-- RLS有効化
ALTER TABLE points ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own points" ON points 
    FOR SELECT USING (auth.uid() = user_id);
```

## リレーション
- **users.id** → **profiles.id**（1対1）
- **users.id** → **images.user_id**（1対多）
- **users.id** → **likes.from_user_id**（1対多）
- **users.id** → **likes.to_user_id**（1対多）
- **users.id** → **matches.user1_id**（1対多）
- **users.id** → **matches.user2_id**（1対多）
- **matches.id** → **messages.match_id**（1対多）
- **users.id** → **messages.sender_id**（1対多）
- **users.id** → **notifications.user_id**（1対多）
- **users.id** → **verification_documents.user_id**（1対多）
- **users.id** → **points.user_id**（1対多、Phase2）